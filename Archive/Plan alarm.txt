potrebno je napraviti modul za kontrolu alarma za koji je pripremljen placeholder u kodu 
ovaj modul treba da ima settings meni koji ćemo numeristi po redu 
settings meni sadrži odabire binarnih adresa za aktiviranje/deaktiviranje alarma 1 relej za
kompletan sistem i 3 particije kao i feedback digitalne ulaze za stanje particije/alarma naoružana/razoružana
dodatno još jedan digitalni feedback ulaz za stanje sistema da li je u alarmu, dodatno koristi i jedan spinbox
za podešavanje dužine pulsa koji ujedno određuje i tip kontrole Momentary (toggle) ili Maintained (latched) dakle 
ako je podešena dužina pulsa koristimo  Momentary (toggle) tip kontrole a ako ne korisićemo latched tipove releja
dodatno imamo i jednu adresu za silent alarm koju koristi dugme SOS  ako je odabrano kao ikona na select ekranima
frontend korisnika treba da sadrži dugme za odabir toggle tipa ARM/DISARM već prema stanju sa feedbacka tako treba
da je i ponuđena opcija dakle uvijek suprotna
klik na bilo koje dugme ARM/DISARM treba da pokrene pinpad za unos šifre korisnika i samo ispravan user kod 
omogućava promjenu, uvijek pri ulasku u meni prvo tražimo trenutno stanje svih particija sa digitalnog input modula 
na busu i po tome crtamo trenutne kontrole tako ćemo izbjeći komplikacije oko tipkovnicom (override) stanja
GUI alarma treba imati standardno desni gornji hamburger meni za izlazak na prethodni select ekran što već i ima


da se malo zadržimo na ovom prijedlogu Korak 2: Kreiranje Novog Ekrana za Upravljanje PIN-ovima
Kreiraćemo novi ekran, SCREEN_SETTINGS_SECURITY_PINS. Njegov izgled bi bio sljedeći:

Naslov: "Podešavanje PIN-ova"
Lista Korisnika:
Tekst: "Korisnik 1" | Prikaz trenutnog PIN-a (maskiran: ****) | Dugme: [ Promijeni ]
Tekst: "Korisnik 2" | Prikaz trenutnog PIN-a (maskiran: ****) | Dugme: [ Promijeni ]
Tekst: "Korisnik 3" | Prikaz trenutnog PIN-a (maskiran: ****) | Dugme: [ Promijeni ]
Navigacija:
Dugme [ Nazad ] za povratak na SCREEN_SELECT_2.
Dugme [ Snimi ] za čuvanje promjena.
Sve tekstualne labele ćemo dodati u translations.h radi podrške za više jezika. 
treba da imaš u vidu da imamo hamburger meni na ovom ekranu koji nas vodi nazad 
na select ekran gdje smo kliknuli ikonisu ALARM tako da je dugme otkaži suvišno 
a po meni je suvišno i snimi dugme obzirnom da će nas tastatura dva ili tri puta 
voditi kroz proces validacije i uvijek možemo kliknuti hamburger meni da se vratimo 
nazad kroz sve ekrane dakle da poništimo u bilo kojem dijelu procesa sve što smo do 
tada odabrali sve do tada, sam unos drugog ili  trećeg validnog pina je ujedno i 
potvrda jer ne ulazi se u ove ekrane slučajni,druga stvar koju prije ove definicije 
treba da razjasnimo do kraja jeste čemu služe tri šifre da li potrebne i da li da 
vežemo pinove za particije ili da koristimo user 1,2,3 ali da nekako odaberemo koje 
particije pripadaju svakom od tri korisnika, po meni je ovo nejasno sada i ako ćeš 
pravo po malo mi je glupo da dupliramo komande koje već postoje na svakom alarmnom 
sistemu imaš li neki pametniji prijedlog možda da koristimo samo jedan pin da ne 
komplikujemo ili šta predlažeš da je najbolje jer ovdje pokušavamo da olakšamo 
korisniku koliko god možemo ali da ne narušavamo security jer ako ćeš istinu sa 
terena jer ja se često sustrećem sa tim, ljudi koji već 5 godina koriste alarmni 
sistem svaki dan uključi/isključi ni dan danas ne znaju šta da urade ako samo jednom 
više pritisnu neku tipku, staju zbunjeni i nema šanse da savladaju šta je to što se 
sad odjednom pojavilo na ekranu.to je činjenica i svaka dodatna opcija je kao partija 
šaha za neke ljude, ja bih najradije da se ukuca samo jedan pin i da se odabere što bi  
možda najlakše bilo ne particija 1,2,3 nego sprat 1,2,3,4 i sl a da se alarm isprogramira 
da koristi zone kao particije koji odgovaraju tom nazivu ali naravno ne možemo ovo 
napamet raditit jer je najlakše nešto lupetati bez pokrića i za ovaj scenario bi 
nam trebo barem jedan dva sigurnosna sistema npr. paradox taj i taj sa tim i tim 
ektenzijama može 100% zadovoljiti ovakvu vrstu konfiguracije i to bi bio standardni 
request od nas prije ugradnje da se nabavi ta oprema i da se uradi kabliranje po tom 
sistemu i onda nema nikakvih preobleme inače ima druga GLUPLJA varijanta pa neka odaberu 
ali da imamo confor konfiguraciju 100% za koju garantujemo da radi šta ti misliš o ovome?

Project Plan v2.0: Smart Home Alarm Module Refactoring (with i18n)
Autor: Gemini
Datum: 6. oktobar 2025.


Cilj projekta: Refaktorisati i dovršiti funkcionalnost Alarm modula u skladu sa usvojenim prijedlozima. 


Glavni ciljevi:

Uspostaviti konzistentan UI/UX za ulazak u podešavanja (dugi pritisak). 

Pojednostaviti upravljanje alarmom uvođenjem "Garantovane Konfiguracije" sa jednim glavnim PIN-om i logičkim, korisnički definisanim nazivima particija. 

Implementirati siguran, trostupanjski proces za promjenu glavnog PIN-a. 

NOVO: Osigurati da je kompletan novi interfejs višejezičan (i18n) i da prikaz naziva particija koristi pametnu logiku (custom naziv ili default prevedeni naziv).

Faza 1: Proširenje Backend-a (Moduli security i main)
Zavisnosti: Ova faza je apsolutni preduslov za sve UI izmjene. Mora biti završena prva. 

Zadatak 1.1: Modifikacija Security_Settings_t strukture.

Fajl: security.h


Akcija: Dodaću polja system_name[21] i partition_names[SECURITY_PARTITION_COUNT][21] unutar Security_Settings_t strukture, odmah nakon magic_number, kako je planirano. Dužina od 21 karaktera je potvrđena. 



Zadatak 1.2: Ažuriranje security.c logike.

Fajl: security.c

Akcije:

Ažurirati Security_SetDefault(): Inicijalizovaću nova polja sa podrazumijevanim, ali NEPREVEDENIM nazivima ("SYSTEM", "PARTITION 1", itd.). Prevođenje je posao frontend-a. 


Kreirati nove getter/setter funkcije: Implementiraću Security_GetSystemName, Security_SetSystemName, Security_GetPartitionName, i Security_SetPartitionName kako je planirano. 

Zadatak 1.3: Verifikacija i implementacija Glavnog PIN-a.

Fajlovi: main.c, security.c

Akcije:

Potvrđujem da 

RAM_Init() u main.c ispravno postavlja default PIN "6776". 

Modifikovaću funkciju 

Security_ValidateUserCode u security.c da vrši poređenje (strcmp) samo sa globalnom varijablom system_pin, umjesto iteracije kroz listu korisnika. Logika za više korisnika (


Security_Users_t) se ignoriše, ali kod ostaje. 

Faza 1.5: Priprema za Internacionalizaciju (i18n)
Zavisnosti: Radi se prije Faze 2.

Zadatak 1.5.1: Proširenje display.h fajla.

Fajl: display.h

Akcija: U TextID enum, dodaću nove identifikatore za sve tekstove potrebne za alarm i proces promjene PIN-a.

C

// Novi TextID-jevi za dodati
TXT_PIN_ENTER_CURRENT,      // Naslov: "TRENUTNI PIN"
TXT_PIN_ENTER_NEW,          // Naslov: "UNESITE NOVI PIN"
TXT_PIN_CONFIRM_NEW,        // Naslov: "POTVRDITE NOVI PIN"
TXT_PIN_WRONG,              // Poruka: "POGREŠAN PIN"
TXT_PINS_DONT_MATCH,        // Poruka: "PIN-ovi se ne podudaraju"
TXT_PIN_CHANGE_SUCCESS,     // Poruka: "PIN uspješno promijenjen"
TXT_ALARM_CHANGE_PIN,       // Labela dugmeta: "Promijeni Glavni PIN"
TXT_ALARM_SYSTEM_NAME,      // Labela dugmeta: "Naziv Sistema"
TXT_ALARM_PARTITION_NAME    // Labela dugmeta (koristiće se kao prefiks, npr. "Naziv Particije 1")
Zadatak 1.5.2: Proširenje translations.h fajla.

Fajl: translations.h

Akcija: Dodaću prevode za sve nove TextID-jeve u language_strings tabelu, počevši sa BSHC jezikom.

C

// Primjer dodavanja u translations.h
/* TXT_PIN_ENTER_CURRENT */  { "TRENUTNI PIN", "CURRENT PIN", ... },
/* TXT_PIN_ENTER_NEW */      { "UNESITE NOVI PIN", "ENTER NEW PIN", ... },
...
Faza 2: Implementacija UI za Podešavanje Alarma (Modul display)
Zavisnosti: Faza 1 i 1.5 moraju biti završene.

Zadatak 2.1: Kreiranje ekrana SCREEN_SETTINGS_ALARM (sa i18n).

Fajlovi: display.h, display.c

Akcije:

Dodati 

SCREEN_SETTINGS_ALARM u eScreen enum. 

Kreirati 

DSP_InitSettingsAlarmScreen(), DSP_KillSettingsAlarmScreen() i Service_SettingsAlarmScreen(). 

U 

Init funkciji, kreirati 5 dugmadi.  Za tekst na dugmadima, implementiraću 

pametnu logiku prikaza:

Dugme 1: BUTTON_SetText(hButton, lng(TXT_ALARM_CHANGE_PIN));

Dugmad 2-5:

C

// Primjer za Particiju 1 (indeks 0)
const char* custom_name = Security_GetPartitionName(0);
char buffer[50];
if (custom_name[0] == '\0') {
    // Ako nema custom naziva, koristi default prevedeni
    sprintf(buffer, "%s 1", lng(TXT_ALARM_PARTITION));
} else {
    // Ako postoji custom naziv, koristi njega
    strncpy(buffer, custom_name, sizeof(buffer));
}
BUTTON_SetText(hButton, buffer);
Zadatak 2.2: Implementacija trostupanjske promjene PIN-a (sa i18n).

Fajl: display.c

Akcije:

Definisaću statički 

enum za praćenje stanja (PIN_CHANGE_IDLE, itd.). 

Na pritisak dugmeta "Promijeni Glavni PIN", pozvaću 

Display_ShowNumpad() sa naslovom lng(TXT_PIN_ENTER_CURRENT). 

Proširiću 

Service_NumpadScreen() da upravlja cijelim trostupanjskim procesom, koristeći lng() za sve naslove ("UNESITE NOVI PIN", "POTVRDITE NOVI PIN") i poruke o grešci (lng(TXT_PIN_WRONG), lng(TXT_PINS_DONT_MATCH)). 

Zadatak 2.3: Implementacija promjene naziva particija (sa i18n).

Fajl: display.c

Akcije:

Na pritisak dugmeta za naziv particije, pozvaću 

Display_ShowKeyboard(). 

Kontekst za tastaturu ću popuniti sa dinamički kreiranim, prevedenim naslovom i trenutnim nazivom particije. 

Nakon potvrde, 

Service_KeyboardScreen će pozvati Security_SetPartitionName() i Security_Save(). 

Faza 3: Refaktorisanje UI Navigacije (Moduli display, timer)
Zavisnosti: Nema.

Zadatak 3.1: Implementacija dugog pritiska za ALARM i TIMER.

Fajl: display.c


Akcija: U HandlePress_SelectScreen2 ću dodati start tajmera , a u 

HandleTouchReleaseEvent provjeru trajanja za razlikovanje kratkog i dugog pritiska, što će voditi na odgovarajuće ekrane (SCREEN_SECURITY/SCREEN_TIMER vs SCREEN_SETTINGS_ALARM/SCREEN_SETTINGS_TIMER). 


Zadatak 3.2: Uklanjanje "Settings" ikonice sa TIMER ekrana.

Fajl: display.c


Akcija: Izbrisaću kod za kreiranje i obradu hButtonTimerSettings unutar Service_TimerScreen i povezanih funkcija. 

Zadatak 3.3: Ažuriranje SCREEN_SECURITY za prikaz novih naziva.

Fajl: display.c


Akcija: U Service_SecurityScreen, umjesto fiksnih stringova, koristiću istu pametnu logiku kao u Zadatku 2.1 za dinamički prikaz naziva na dugmadima, pozivajući getter funkcije iz security.c. 

Moj Sljedeći Korak (početak nove sesije):
Otvoriću fajlove security.h i security.c.

Započeću sa 

Zadatkom 1.1: Proširiću Security_Settings_t strukturu sa poljima za nazive. 

Nastaviću sa 

Zadatkom 1.2: Implementiraću SetDefault izmjene i kreirati nove getter/setter funkcije za nazive. 

Zatim prelazim na Zadatak 1.5: Ažuriraću display.h i translations.h.

Tek nakon toga, počinjem sa UI izmjenama u 

display.c kako je opisano u Fazama 2 i 3. 